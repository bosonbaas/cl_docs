{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Unofficial Desmos CL Reference # This site is an unofficial reference for the Desmos CL syntax, intended to be up-to-date on newly introduced syntax. If you find this useful, fantastic! If there's anything you'd like to see added/changed about the current layout, please drop a request on the GitHub repository, or even open up a pull request! What you'll find here: Reference material that clarifies how CL expressions and state work. Tips, patterns, and troubleshooting notes from my own (and other contributors) experience workign with CL. This is intended as a reference for those already familiar with Desmos CL. If you're just starting, I'd encourage you to take a look at the official Desmos CL documentation here Disclaimer: Visit Amplify Classroom for free lessons, lesson-building tools, and Polypad virtual manipulatives at amplifycom.wpengine.com/classroom. This content is not affiliated with, sponsored by, or endorsed by Amplify or any of its licensors. Amplify\u00ae, Amplify Classroom\u2122, and related trademarks are the property of Amplify Education, Inc. Contributing # If you've looked around the website, you may notice that there are a lot of things missing! For example, what about those one-off functions like parseOrderedPair ? And half of the components don't have a comprehensive list of types, what's up with that?? Thus, contributions are welcomed and needed ! If you're comfortable with GitHub, then head over to the Github page and open up an issue, or if you're really ambitious make a pull request! If you're not super comfortable with that, but still want to help fill in the documentation, feel free email me at unofficialcldocs@gmail.com ! Additionally, if you have neat examples or hacks that you've developed and you think others would find helpful, please send them on in, and we can make them a resource for the rest of the community. Useful links # Official Desmos CL documentation here Official CL forum here","title":"Home"},{"location":"#the-unofficial-desmos-cl-reference","text":"This site is an unofficial reference for the Desmos CL syntax, intended to be up-to-date on newly introduced syntax. If you find this useful, fantastic! If there's anything you'd like to see added/changed about the current layout, please drop a request on the GitHub repository, or even open up a pull request! What you'll find here: Reference material that clarifies how CL expressions and state work. Tips, patterns, and troubleshooting notes from my own (and other contributors) experience workign with CL. This is intended as a reference for those already familiar with Desmos CL. If you're just starting, I'd encourage you to take a look at the official Desmos CL documentation here Disclaimer: Visit Amplify Classroom for free lessons, lesson-building tools, and Polypad virtual manipulatives at amplifycom.wpengine.com/classroom. This content is not affiliated with, sponsored by, or endorsed by Amplify or any of its licensors. Amplify\u00ae, Amplify Classroom\u2122, and related trademarks are the property of Amplify Education, Inc.","title":"The Unofficial Desmos CL Reference"},{"location":"#contributing","text":"If you've looked around the website, you may notice that there are a lot of things missing! For example, what about those one-off functions like parseOrderedPair ? And half of the components don't have a comprehensive list of types, what's up with that?? Thus, contributions are welcomed and needed ! If you're comfortable with GitHub, then head over to the Github page and open up an issue, or if you're really ambitious make a pull request! If you're not super comfortable with that, but still want to help fill in the documentation, feel free email me at unofficialcldocs@gmail.com ! Additionally, if you have neat examples or hacks that you've developed and you think others would find helpful, please send them on in, and we can make them a resource for the rest of the community.","title":"Contributing"},{"location":"#useful-links","text":"Official Desmos CL documentation here Official CL forum here","title":"Useful links"},{"location":"about/","text":"About This Project # With a background in software engineering, when I first started working with the Desmos Computation Layer (CL) , I found myself often longing for a website that provides the bare-bones syntax rules and documentation of Desmos CL. While I understand that for the majority of Desmos CL users the existing resources may be more than enough, maybe there are some others like me out there who would appreciate this resource.","title":"About"},{"location":"about/#about-this-project","text":"With a background in software engineering, when I first started working with the Desmos Computation Layer (CL) , I found myself often longing for a website that provides the bare-bones syntax rules and documentation of Desmos CL. While I understand that for the majority of Desmos CL users the existing resources may be more than enough, maybe there are some others like me out there who would appreciate this resource.","title":"About This Project"},{"location":"components/","text":"Components # Components are the building blocks of Amplify Classroom's activities, and are the pieces tied together and controlled with CL. Components connect to each other by their sinks and sources . The sinks of a component are the values which define its appearance and behavior, and the sources of a component are variables which contain the state of the component. This resource is intended to be a quick reference for the data types and purpose of each source and sink. For a more interactive and official documentation, see Amplify's Documentation . Note # Sink Type Description content string | latex Content of the note. hidden boolean Hides the component when true Source Type Description Free Response # Sink Type Description initialText string | latex Initial text of the free response. Often a prompt for student input. placeholderText string | latex Placeholder text of the free response. (default value of response) showSubmitButton boolean Hides submit button if true . submitDisabled boolean Disables the submit button if false . submitLabel string | latex A label for the submit button. hidden boolean Hides the component when true Source Type Description content string The current entered content. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value. Math Response # Sink Type Description capture(key::string) number Capture a numeric value (often the evaluated result of the submission), which can later be referenced with key clearOnReset boolean Description needed correct boolean Displays a checkmark in the student summary screen if true disableEdit boolean Disables editing the expression if true disableEvaluation boolean Does not evaluate the expression for the student when true errorMessage string Error message to show the student after attempted submission. Blocks submission when not empty. explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialLatex string | latex The initial text in the expression input initialText string | latex The initial text in the text input under \"Explain your thinking\" placeholderLatex string | latex The placeholder for the expression input. readOnly boolean Description needed resetLabel string Specifies a label for the button that allows the student to edit their answer. resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitDisabled boolean Disables the submit button if false . submitLabel string | latex A label for the submit button. suffix string Adds this suffix to the end of student input. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description explainContent string The current content of the \"Explain your thinking\" box history List<number> The history of the key variable (same key should appear in a capture statement in the component) lastValue number The last value of the key variable latex latex The latex content of the expression input. numericValue number The numeric value of the expression input. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value. Multiple Choice # Sink Type Description choiceContent(index::number) string Sets the content of index choice. correct boolean Displays a checkmark in the student summary screen if true disableChange boolean Disables changing a selection if true explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialText string | latex The initial text in the text input under \"Explain your thinking\" maxButtonsPerRow number Max numbers of buttons laid out in each row prompt string Sets the prompt above the selections. readOnly boolean Description needed resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitLabel string | latex A label for the submit button. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description choiceContent string The content for the choice of index index explainContent string The current content of the \"Explain your thinking\" box isSelected boolean Whether the choice at index choiceIndex is selected. isSelectedList List<boolean> Boolean list indicating which selections are selected. matchesKey boolean Returns true if the current answer matches a provided answer key. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value. Checkboxes # Sink Type Description choiceContent(index::number) string Sets the content of index choice. correct boolean Displays a checkmark in the student summary screen if true disableChange boolean Disables changing a selection if true explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialText string | latex The initial text in the text input under \"Explain your thinking\" maxButtonsPerRow number Max numbers of buttons laid out in each row maxSelectedChoices number Maximum number of choices that can be selected. prompt string Sets the prompt above the selections. readOnly boolean Description needed resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitLabel string | latex A label for the submit button. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description choiceContent string The content for the choice of index index explainContent string The current content of the \"Explain your thinking\" box isSelected boolean Whether the choice at index choiceIndex is selected. isSelectedList List<boolean> Boolean list indicating which selections are selected. matchesKey boolean Returns true if the current answer matches a provided answer key. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value. Ordered List # Sink Type Description correct boolean Displays a checkmark in the student summary screen if true hidden boolean Hides the component when true initialOrder List<number> Defines the initial ordering of the items. Orders items based on the order of the numbers in the list (integers not necessary) itemContent(index::number) string Sets the content of item at index . readOnly boolean Description needed warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description indexOfItem number Returns the resulting index of an item that started at initialItemIndex itemAtIndex number Returns the initial index of the item that ended up at itemIndex . matchesKey boolean Returns true if the current answer matches a provided answer key. order List<number> List of indexs where items currently are textAtIndex string The text at index itemIndex . timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value. Graph # Sink Type Description Source Type Description Sketch # Sink Type Description Source Type Description Media # Sink Type Description Source Type Description Table # Sink Type Description Source Type Description Action Button # Sink Type Description Source Type Description Polypad # Sink Type Description Source Type Description","title":"Components"},{"location":"components/#components","text":"Components are the building blocks of Amplify Classroom's activities, and are the pieces tied together and controlled with CL. Components connect to each other by their sinks and sources . The sinks of a component are the values which define its appearance and behavior, and the sources of a component are variables which contain the state of the component. This resource is intended to be a quick reference for the data types and purpose of each source and sink. For a more interactive and official documentation, see Amplify's Documentation .","title":"Components"},{"location":"components/#note","text":"Sink Type Description content string | latex Content of the note. hidden boolean Hides the component when true Source Type Description","title":"Note"},{"location":"components/#free-response","text":"Sink Type Description initialText string | latex Initial text of the free response. Often a prompt for student input. placeholderText string | latex Placeholder text of the free response. (default value of response) showSubmitButton boolean Hides submit button if true . submitDisabled boolean Disables the submit button if false . submitLabel string | latex A label for the submit button. hidden boolean Hides the component when true Source Type Description content string The current entered content. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value.","title":"Free Response"},{"location":"components/#math-response","text":"Sink Type Description capture(key::string) number Capture a numeric value (often the evaluated result of the submission), which can later be referenced with key clearOnReset boolean Description needed correct boolean Displays a checkmark in the student summary screen if true disableEdit boolean Disables editing the expression if true disableEvaluation boolean Does not evaluate the expression for the student when true errorMessage string Error message to show the student after attempted submission. Blocks submission when not empty. explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialLatex string | latex The initial text in the expression input initialText string | latex The initial text in the text input under \"Explain your thinking\" placeholderLatex string | latex The placeholder for the expression input. readOnly boolean Description needed resetLabel string Specifies a label for the button that allows the student to edit their answer. resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitDisabled boolean Disables the submit button if false . submitLabel string | latex A label for the submit button. suffix string Adds this suffix to the end of student input. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description explainContent string The current content of the \"Explain your thinking\" box history List<number> The history of the key variable (same key should appear in a capture statement in the component) lastValue number The last value of the key variable latex latex The latex content of the expression input. numericValue number The numeric value of the expression input. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value.","title":"Math Response"},{"location":"components/#multiple-choice","text":"Sink Type Description choiceContent(index::number) string Sets the content of index choice. correct boolean Displays a checkmark in the student summary screen if true disableChange boolean Disables changing a selection if true explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialText string | latex The initial text in the text input under \"Explain your thinking\" maxButtonsPerRow number Max numbers of buttons laid out in each row prompt string Sets the prompt above the selections. readOnly boolean Description needed resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitLabel string | latex A label for the submit button. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description choiceContent string The content for the choice of index index explainContent string The current content of the \"Explain your thinking\" box isSelected boolean Whether the choice at index choiceIndex is selected. isSelectedList List<boolean> Boolean list indicating which selections are selected. matchesKey boolean Returns true if the current answer matches a provided answer key. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value.","title":"Multiple Choice"},{"location":"components/#checkboxes","text":"Sink Type Description choiceContent(index::number) string Sets the content of index choice. correct boolean Displays a checkmark in the student summary screen if true disableChange boolean Disables changing a selection if true explainPrompt string Replaces the \"Explain your thinking\" prompt. hidden boolean Hides the component when true initialText string | latex The initial text in the text input under \"Explain your thinking\" maxButtonsPerRow number Max numbers of buttons laid out in each row maxSelectedChoices number Maximum number of choices that can be selected. prompt string Sets the prompt above the selections. readOnly boolean Description needed resetOnChange string Resets the expression when the string itself changes. showExplain boolean If true , then show the request for student to explain answer. showPeerResponses boolean Description needed showSubmitButton boolean Hides submit button if true . submitLabel string | latex A label for the submit button. warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description choiceContent string The content for the choice of index index explainContent string The current content of the \"Explain your thinking\" box isSelected boolean Whether the choice at index choiceIndex is selected. isSelectedList List<boolean> Boolean list indicating which selections are selected. matchesKey boolean Returns true if the current answer matches a provided answer key. submitCount number The number of submissions the student has made. submitted boolean true if the component is submitted timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value.","title":"Checkboxes"},{"location":"components/#ordered-list","text":"Sink Type Description correct boolean Displays a checkmark in the student summary screen if true hidden boolean Hides the component when true initialOrder List<number> Defines the initial ordering of the items. Orders items based on the order of the numbers in the list (integers not necessary) itemContent(index::number) string Sets the content of item at index . readOnly boolean Description needed warning string Puts a warning on the teacher dashboard associated with the student. Source Type Description indexOfItem number Returns the resulting index of an item that started at initialItemIndex itemAtIndex number Returns the initial index of the item that ended up at itemIndex . matchesKey boolean Returns true if the current answer matches a provided answer key. order List<number> List of indexs where items currently are textAtIndex string The text at index itemIndex . timeSinceSubmit number Returns number of seconds since submit button was pressed. Can take one parameter maxTime , and will use this as a ceiling for its output value.","title":"Ordered List"},{"location":"components/#graph","text":"Sink Type Description Source Type Description","title":"Graph"},{"location":"components/#sketch","text":"Sink Type Description Source Type Description","title":"Sketch"},{"location":"components/#media","text":"Sink Type Description Source Type Description","title":"Media"},{"location":"components/#table","text":"Sink Type Description Source Type Description","title":"Table"},{"location":"components/#action-button","text":"Sink Type Description Source Type Description","title":"Action Button"},{"location":"components/#polypad","text":"Sink Type Description Source Type Description","title":"Polypad"},{"location":"functions/","text":"Functions #","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"lists/","text":"Lists # Lists in CL can be explicitly defined by providing a comma-separated list of elements. Note, all elements of a list in CL must be of the same datatype. Elements of lists can be lists themselves but, once again, they must all be the same type of list. For example, we can define a list of number s List Operations # List operations are described in-detail here . Below is a cheat-sheet, as well as some worked examples I've found useful. As a note, the first few of these functions take in an arrow function as an argument. Arrow functions are functions which you define, and which (in CL) can only be defined inline (that is, in the function call itself). An example of an arrow function is: (x) => numericValue(`${x}+1`) This function would take in an argument ( x ), and return x+1 (though the CL syntax makes that a little ... unwieldly). So if we were to use this in the CL map function (which applies the arrow function to every element of an list) we would have: test = [1,2,3,4].map((x) => numericValue(`${x}+1`)) # This stores [2,3,4,5] in the \"test\" variable Lists.map() # list.map(func::ArrowFunction)::List This function returns a list containing the result of calling the arrow function func on each element of the original list. The arrow function func can be defined with either 0, 1, or 2 arguments. Note that CL doesn't care what you call the arguments in your arrow function definition, just how many arguments there are and their positions. 0 arguments () => ... : The function accepts no arguments. 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element. Use-Cases # Creating a list full of zeros the same size as another list (maybe keeping score in a game). players = [\"Student1\", \"Student2\", \"Student3\"] score = players.map(() => 0) Applying a function to a list of student-defined x-values. x_coords = [1, 2, 3, 5, 8, 9, -1, -2] y_coords = x_coords.map((x) => numericValue(`${x}^2`)) # Note that even though we call the single argument 'x', it will # still be the respective element of the 'x_coords' list. Multiplying two lists element-wise. list_1 = [5, 3, 7, 12, 3] list_2 = [-1, 1, 0, 2, 4] list_3 = list_1.map((x, i) => numericValue(`$(x) * $(list_2[i]))) Lists.filter() # list.filter(func::ArrowFunction)::List This function returns a list containing only the elements of list which return true when passed to func . The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element. Use-Cases # Identifying the first even value of a list. Lists.first() # list.first(func::ArrowFunction)::Type This function is similar to filter , but only returns the first element of list which returns true when passed to func . The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element. Use-Cases # Find the first value greater than 2 in a list. 1 values = [1,3,5,6,7] first_gt_2 = values.first((e) => e > 2) # first_gt_2 should equal 3. Lists.all() # list.all(func::ArrowFunction)::boolean This function returns true if func returns true for all elements in the list, and false otherwise. The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element. Use-Cases # Evaluate if all elements of a list are greater than 2 1 values = [1,3,5,6,7] all_gt_2 = values.all((e) => e > 2) # all_gt_2 should be false Lists.any() # list.any(func::ArrowFunction)::boolean This function returns true if func returns true for any elements in the list, and false otherwise. The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element. Use-Cases # Evaluate if any elements of a list are greater than 2 1 values = [1,3,5,6,7] any_gt_2 = values.any((e) => e > 2) # any_gt_2 should be true Lists.reduce() # list.reduce(init::Type, func::ArrowFunction)::Type This function returns the result of calling func on each element of the list, with the results being compounded using the acc argument described below. The arrow function func can be defined with either 2 or 3 arguments. 1 argument (acc, cur) => ... : The function takes in two arguments: acc as the accumulated value and cur as the current list element. 2 arguments (acc, cur, index) => ... : The function takes in three arguments: acc as the accumulated value, cur as the current list element, and index as the index of the current element. Use-Cases # Making a string of all elements of a list. values = [1, 3, 4, 6, 5, 2] values_string = values.slice(2,values.length).reduce(\"${values[1]}\", (acc, cur) => \"$(acc), $(cur)\") # values_string should contain '1, 3, 4, 6, 5, 2' Sum all elements of a list. values = [1, 3, 4, 6, 5, 2] values_sum = values.reduce(0, (acc, cur) => numericValue(\"$(acc) + $(cur)\")) # values_sum should contain 21 Lists.slice() # list.slice(start_ind::number, end_ind::number)::List slice makes a copy of a section of list , starting with the element at start_ind and ending with the element at end_ind . Note that while these indices generally should be integers, CL seems to accept any number (including negative). Use-Cases # Getting the first half of a list. values = [1, 3, 4, 6, 5, 2] first_values = values.slice(1, numericValue(\"${values.length} / 2\")) # first_values should contain [1, 3, 4] Lists.join() # list.join(list2::List)::List join returns the result of appending list2 to list . Use-Cases # Merging two lists together. 1 v1 = [1, 3, 4] v2 = [6, 5, 2] values = v1.join(v2) # values should contain [1, 3, 4, 6, 5, 2] Lists.reverse() # list.reverse()::List reverse returns a copy of list in reversed order. Use-Cases # Reversing a list. 1 values = [1, 3, 4, 6, 5, 2] rev_values = v1.join(v2) # values should contain [2, 5, 6, 4, 3, 1] range() # range(lower::number, upper::number, step::number)::List<number> range(lower::number, upper::number)::List<number> range(upper::number)::List<number> Returns a list which starts at lower and counts up to upper with step sizes of size step . If step is not specificied, it defaults to 1. If lower is not specificied, it defaults to 1. If the step size is negative, it will count backwards from lower to upper (in this case, lower will need to be greater than upper ). This will return undefined if step is not a nonzero integer. Use-Cases # Creating a list of evenly spaced numbers. 1 r1 = range(5) # r1 is [1, 2, 3, 4, 5] r2 = range(2, 5) # r2 is [2, 3, 4, 5] r3 = range(2, 5, 2) # r3 is [2, 4] r4 = range(5, 2, -2) # r4 is [5, 3] Add a more compelling example here. Want to contribute? See the Contribution section \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Lists"},{"location":"lists/#lists","text":"Lists in CL can be explicitly defined by providing a comma-separated list of elements. Note, all elements of a list in CL must be of the same datatype. Elements of lists can be lists themselves but, once again, they must all be the same type of list. For example, we can define a list of number s","title":"Lists"},{"location":"lists/#list-operations","text":"List operations are described in-detail here . Below is a cheat-sheet, as well as some worked examples I've found useful. As a note, the first few of these functions take in an arrow function as an argument. Arrow functions are functions which you define, and which (in CL) can only be defined inline (that is, in the function call itself). An example of an arrow function is: (x) => numericValue(`${x}+1`) This function would take in an argument ( x ), and return x+1 (though the CL syntax makes that a little ... unwieldly). So if we were to use this in the CL map function (which applies the arrow function to every element of an list) we would have: test = [1,2,3,4].map((x) => numericValue(`${x}+1`)) # This stores [2,3,4,5] in the \"test\" variable","title":"List Operations"},{"location":"lists/#listsmap","text":"list.map(func::ArrowFunction)::List This function returns a list containing the result of calling the arrow function func on each element of the original list. The arrow function func can be defined with either 0, 1, or 2 arguments. Note that CL doesn't care what you call the arguments in your arrow function definition, just how many arguments there are and their positions. 0 arguments () => ... : The function accepts no arguments. 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element.","title":"Lists.map()"},{"location":"lists/#use-cases","text":"Creating a list full of zeros the same size as another list (maybe keeping score in a game). players = [\"Student1\", \"Student2\", \"Student3\"] score = players.map(() => 0) Applying a function to a list of student-defined x-values. x_coords = [1, 2, 3, 5, 8, 9, -1, -2] y_coords = x_coords.map((x) => numericValue(`${x}^2`)) # Note that even though we call the single argument 'x', it will # still be the respective element of the 'x_coords' list. Multiplying two lists element-wise. list_1 = [5, 3, 7, 12, 3] list_2 = [-1, 1, 0, 2, 4] list_3 = list_1.map((x, i) => numericValue(`$(x) * $(list_2[i])))","title":"Use-Cases"},{"location":"lists/#listsfilter","text":"list.filter(func::ArrowFunction)::List This function returns a list containing only the elements of list which return true when passed to func . The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element.","title":"Lists.filter()"},{"location":"lists/#use-cases_1","text":"Identifying the first even value of a list.","title":"Use-Cases"},{"location":"lists/#listsfirst","text":"list.first(func::ArrowFunction)::Type This function is similar to filter , but only returns the first element of list which returns true when passed to func . The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element.","title":"Lists.first()"},{"location":"lists/#use-cases_2","text":"Find the first value greater than 2 in a list. 1 values = [1,3,5,6,7] first_gt_2 = values.first((e) => e > 2) # first_gt_2 should equal 3.","title":"Use-Cases"},{"location":"lists/#listsall","text":"list.all(func::ArrowFunction)::boolean This function returns true if func returns true for all elements in the list, and false otherwise. The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element.","title":"Lists.all()"},{"location":"lists/#use-cases_3","text":"Evaluate if all elements of a list are greater than 2 1 values = [1,3,5,6,7] all_gt_2 = values.all((e) => e > 2) # all_gt_2 should be false","title":"Use-Cases"},{"location":"lists/#listsany","text":"list.any(func::ArrowFunction)::boolean This function returns true if func returns true for any elements in the list, and false otherwise. The arrow function func can be defined with either 1 or 2 arguments. func should return either true or false . 1 argument (element) => ... : The function takes in one argument: the respective element of the original list. 2 arguments (element, index) => ... : The function takes in two arguments: the respective element of the original list and the index of that element.","title":"Lists.any()"},{"location":"lists/#use-cases_4","text":"Evaluate if any elements of a list are greater than 2 1 values = [1,3,5,6,7] any_gt_2 = values.any((e) => e > 2) # any_gt_2 should be true","title":"Use-Cases"},{"location":"lists/#listsreduce","text":"list.reduce(init::Type, func::ArrowFunction)::Type This function returns the result of calling func on each element of the list, with the results being compounded using the acc argument described below. The arrow function func can be defined with either 2 or 3 arguments. 1 argument (acc, cur) => ... : The function takes in two arguments: acc as the accumulated value and cur as the current list element. 2 arguments (acc, cur, index) => ... : The function takes in three arguments: acc as the accumulated value, cur as the current list element, and index as the index of the current element.","title":"Lists.reduce()"},{"location":"lists/#use-cases_5","text":"Making a string of all elements of a list. values = [1, 3, 4, 6, 5, 2] values_string = values.slice(2,values.length).reduce(\"${values[1]}\", (acc, cur) => \"$(acc), $(cur)\") # values_string should contain '1, 3, 4, 6, 5, 2' Sum all elements of a list. values = [1, 3, 4, 6, 5, 2] values_sum = values.reduce(0, (acc, cur) => numericValue(\"$(acc) + $(cur)\")) # values_sum should contain 21","title":"Use-Cases"},{"location":"lists/#listsslice","text":"list.slice(start_ind::number, end_ind::number)::List slice makes a copy of a section of list , starting with the element at start_ind and ending with the element at end_ind . Note that while these indices generally should be integers, CL seems to accept any number (including negative).","title":"Lists.slice()"},{"location":"lists/#use-cases_6","text":"Getting the first half of a list. values = [1, 3, 4, 6, 5, 2] first_values = values.slice(1, numericValue(\"${values.length} / 2\")) # first_values should contain [1, 3, 4]","title":"Use-Cases"},{"location":"lists/#listsjoin","text":"list.join(list2::List)::List join returns the result of appending list2 to list .","title":"Lists.join()"},{"location":"lists/#use-cases_7","text":"Merging two lists together. 1 v1 = [1, 3, 4] v2 = [6, 5, 2] values = v1.join(v2) # values should contain [1, 3, 4, 6, 5, 2]","title":"Use-Cases"},{"location":"lists/#listsreverse","text":"list.reverse()::List reverse returns a copy of list in reversed order.","title":"Lists.reverse()"},{"location":"lists/#use-cases_8","text":"Reversing a list. 1 values = [1, 3, 4, 6, 5, 2] rev_values = v1.join(v2) # values should contain [2, 5, 6, 4, 3, 1]","title":"Use-Cases"},{"location":"lists/#range","text":"range(lower::number, upper::number, step::number)::List<number> range(lower::number, upper::number)::List<number> range(upper::number)::List<number> Returns a list which starts at lower and counts up to upper with step sizes of size step . If step is not specificied, it defaults to 1. If lower is not specificied, it defaults to 1. If the step size is negative, it will count backwards from lower to upper (in this case, lower will need to be greater than upper ). This will return undefined if step is not a nonzero integer.","title":"range()"},{"location":"lists/#use-cases_9","text":"Creating a list of evenly spaced numbers. 1 r1 = range(5) # r1 is [1, 2, 3, 4, 5] r2 = range(2, 5) # r2 is [2, 3, 4, 5] r3 = range(2, 5, 2) # r3 is [2, 4] r4 = range(5, 2, -2) # r4 is [5, 3] Add a more compelling example here. Want to contribute? See the Contribution section \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Use-Cases"},{"location":"patterns/","text":"Patterns # The official documentation on patterns can be found here . WARNING : Patterns are currently a beta feature, so be careful while using them. For advanced pattern usage, take a look at the Desmos CL forums here . Brief Introduction # The different patterns in Desmos CL are tools which can be used to require student answers in certain formats or to parse complex student inputs. Some of these patterns can themselves contain other patterns, like the fraction pattern which requires a pattern for the numerator and denominator. Generating Patterns # I personally think that examples are the best way to learn the peculiar format for defining patterns. Let's say that we want to make a pattern that matches a basic fraction in the format \\(\\frac{a}{b}\\). We could define that as: frac_pattern = patterns.fraction(patterns.number, patterns.number) Then, let's say that students are putting their answer (as a fraction) into a math response component named math_resp . Then we could get the numerator of their response with: frac_pattern.parse(math_resp.latex).numerator().latex The parse method parses the student response and returns an object which we can get the numerator, denominator, or latex from. Note that each pattern object will have different things you can parse out of it (fractions have numerators and denominators, exponents have bases and exponents, etc.). For a more complex pattern example, let's say that we gave our students the challenge of converting \\(\\left(\\frac{a}{b}\\right)^5\\) into a fraction, with an expected answer of \\(\\frac{a^5}{b^5}\\). This would correspond to the following pattern. Note that we can assign patterns to a shorthand variable to reduce the size of our pattern definition. p = patterns ans_pattern = p.fraction(p.exponent(p.literal(\"a\"), p.integer), p.exponent(p.literal(\"b\"), p.integer)) Now that we have the answer, we can first check that the student answer is in this format. To do this, we would use matches like so: ans_matches = ans_pattern.matches(math_resp.latex) Once we've checked that, we can confirm that the exponents are correct by using multiple applications of parse like so: a_exp = ans_pattern.parse(math_resp.latex).numerator().exponent().numericValue b_exp = ans_pattern.parse(math_resp.latex).denominator().exponent().numericValue is_correct = (a_exp = 5) and (b_exp = 5) Pattern Playground # If you want to play around with the different patterns that are possible, below you can find a kind of \"pattern playground\" which will render the latex that corresponds to the kind of pattern you are constructing. Note that \"patterns.\" or \"p.\" both work as prefixes, though only \"patterns.\" will work as a prefix in the CL editor (unless you've included the line p = patterns ). Additionally, this playground only includes a set of the more common patterns (the ones with explanations currently in this documentation). Input your pattern here: Pattern Preview Pattern Warnings Kinds of Patterns # pattern.number # Pattern Attributes # numberPattern Attribute Type Description satisfies(ltx::latex) numberPattern ltx should be some expression containing the variable x which evaluates to either true or false . For example, the following will match only to negative integers: neg_int = patterns.integer.satisfies(`x < 0`) matches(ltx::latex) boolean Description needed parse(ltx::latex) numberPatternMatch Description needed rejectParens numberPattern Description needed allowParens numberPattern Description needed Match Attributes # numberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed pattern.integer # Pattern Attributes # numberPattern Attribute Type Description satisfies(ltx::latex) numberPattern ltx should be some expression containing the variable x which evaluates to either true or false . For example, the following will match only to negative integers: neg_int = patterns.integer.satisfies(`x < 0`) matches(ltx::latex) boolean Description needed parse(ltx::latex) numberPatternMatch Description needed rejectParens numberPattern Description needed allowParens numberPattern Description needed Match Attributes # numberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed pattern.mixedNumber # Pattern Attributes # mixedNumberPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) mixedNumberPatternMatch Description needed Match Attributes # mixedNumberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed whole number Description needed numerator number Description needed denominator number Description needed pattern.scientific # Pattern Attributes # scientificPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) scientificPatternMatch Description needed Match Attributes # scientificPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed coefficient number Description needed exponent number Description needed pattern.literal # patterns.literal(ltx::latex)::literalPattern Pattern Attributes # literalPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) literalPatternMatch Description needed rejectParens literalPattern Description needed allowParens literalPattern Description needed Match Attributes # literalPatternMatch Attribute Type Description latex latex Description needed pattern.expression # Pattern Attributes # expressionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) expressionPatternMatch Description needed rejectParens expressionPattern Description needed allowParens expressionPattern Description needed Match Attributes # expressionPatternMatch Attribute Type Description latex latex Description needed pattern.anyOf # patterns.anyOf(term1::pattern, term2::pattern, ...)::orPattern anyOf accepts any number of terms, and will match any of them. Pattern Attributes # orPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) orPatternMatch Description needed Match Attributes # orPatternMatch Attribute Type Description latex latex Description needed pattern.sum # patterns.sum(term1::pattern, term2::pattern, ...)::sumPattern sum accepts any number of terms, and will match their addition. Pattern Attributes # sumPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) sumPatternMatch Description needed strictOrder sumPattern Description needed rejectParens sumPattern Description needed allowParens sumPattern Description needed rejectNegativeTerms sumPattern Description needed allowNegativeTerms sumPattern Description needed Match Attributes # sumPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.sum call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the sum, one would call: patterns.sum(patterns.integer, patterns.integer).parse(`1+2`).term1 pattern.contains # Pattern Attributes # containsPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) containsPatternMatch Description needed Match Attributes # containsPatternMatch Attribute Type Description latex latex Description needed term1 patternMatch Description needed pattern.product # patterns.product(term1::pattern, term2::pattern, ...)::productPattern product accepts any number of terms, and will match their product. Pattern Attributes # productPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) productPatternMatch Description needed strictOrder productPattern Description needed rejectParens productPattern Description needed allowParens productPattern Description needed Match Attributes # productPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.product call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the product, one would call: patterns.product(patterns.integer, patterns.integer).parse(`1*2`).term1 pattern.juxt # patterns.juxt(term1::pattern, term2::pattern, ...)::juxtPattern juxt accepts any number of terms, and will match their juxtaposition. WARNING : juxt will not recognize the juxtaposition of two numbers (as these are often parsed as a single number) and in general is not completely intuitive. Make sure to test thoroughly when using this feature. Pattern Attributes # juxtPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) juxtPatternMatch Description needed strictOrder juxtPattern Description needed rejectParens juxtPattern Description needed allowParens juxtPattern Description needed Match Attributes # juxtPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.juxt call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the juxt, one would call: patterns.juxt(patterns.integer, patterns.literal(`x`)).parse(`1x`).term1 pattern.fraction # patterns.fraction(numerator::pattern, denominator::pattern)::fractionPattern Pattern Attributes # fractionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) fractionPatternMatch Description needed rejectParens fractionPattern Description needed allowParens fractionPattern Description needed Match Attributes # fractionPatternMatch Attribute Type Description latex latex Description needed numerator patternMatch Description needed denominator patternMatch Description needed pattern.division # patterns.division(dividend::pattern, divisor::pattern)::divisionPattern Pattern Attributes # divisionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) divisionPatternMatch Description needed rejectParens divisionPattern Description needed allowParens divisionPattern Description needed Match Attributes # divisionPatternMatch Attribute Type Description latex latex Description needed divisor patternMatch Description needed dividend patternMatch Description needed pattern.radical # patterns.radical(radicand::pattern, degree::pattern)::radicalPattern Pattern Attributes # radicalPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) radicalPatternMatch Description needed rejectParens radicalPattern Description needed allowParens radicalPattern Description needed Match Attributes # radicalPatternMatch Attribute Type Description latex latex Description needed radicand patternMatch Description needed degree patternMatch Description needed pattern.overLine # Description Needed pattern.overArc # Description Needed pattern.overRightArrow # Description Needed pattern.overLeftArrow # Description Needed pattern.difference # patterns.difference(minuend::pattern, subtrahend::pattern)::pattern Pattern Attributes # differencePattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) differencePatternMatch Description needed rejectParens differencePattern Description needed allowParens differencePattern Description needed Match Attributes # differencePatternMatch Attribute Type Description latex latex Description needed minuend patternMatch Description needed subtrahend patternMatch Description needed pattern.repeat # Description Needed pattern.optional # Description Needed pattern.functionCall # Description Needed pattern.prime # Description Needed pattern.exponent # patterns.exponent(base::pattern, exponent::pattern)::exponentPattern Pattern Attributes # exponentPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) exponentPatternMatch Description needed rejectParens exponentPattern Description needed allowParens exponentPattern Description needed Match Attributes # exponentPatternMatch Attribute Type Description latex latex Description needed base patternMatch Description needed exponent patternMatch Description needed pattern.comparator # Description Needed pattern.comparatorChain # Description Needed pattern.symbol # Description Needed","title":"Patterns"},{"location":"patterns/#patterns","text":"The official documentation on patterns can be found here . WARNING : Patterns are currently a beta feature, so be careful while using them. For advanced pattern usage, take a look at the Desmos CL forums here .","title":"Patterns"},{"location":"patterns/#brief-introduction","text":"The different patterns in Desmos CL are tools which can be used to require student answers in certain formats or to parse complex student inputs. Some of these patterns can themselves contain other patterns, like the fraction pattern which requires a pattern for the numerator and denominator.","title":"Brief Introduction"},{"location":"patterns/#generating-patterns","text":"I personally think that examples are the best way to learn the peculiar format for defining patterns. Let's say that we want to make a pattern that matches a basic fraction in the format \\(\\frac{a}{b}\\). We could define that as: frac_pattern = patterns.fraction(patterns.number, patterns.number) Then, let's say that students are putting their answer (as a fraction) into a math response component named math_resp . Then we could get the numerator of their response with: frac_pattern.parse(math_resp.latex).numerator().latex The parse method parses the student response and returns an object which we can get the numerator, denominator, or latex from. Note that each pattern object will have different things you can parse out of it (fractions have numerators and denominators, exponents have bases and exponents, etc.). For a more complex pattern example, let's say that we gave our students the challenge of converting \\(\\left(\\frac{a}{b}\\right)^5\\) into a fraction, with an expected answer of \\(\\frac{a^5}{b^5}\\). This would correspond to the following pattern. Note that we can assign patterns to a shorthand variable to reduce the size of our pattern definition. p = patterns ans_pattern = p.fraction(p.exponent(p.literal(\"a\"), p.integer), p.exponent(p.literal(\"b\"), p.integer)) Now that we have the answer, we can first check that the student answer is in this format. To do this, we would use matches like so: ans_matches = ans_pattern.matches(math_resp.latex) Once we've checked that, we can confirm that the exponents are correct by using multiple applications of parse like so: a_exp = ans_pattern.parse(math_resp.latex).numerator().exponent().numericValue b_exp = ans_pattern.parse(math_resp.latex).denominator().exponent().numericValue is_correct = (a_exp = 5) and (b_exp = 5)","title":"Generating Patterns"},{"location":"patterns/#pattern-playground","text":"If you want to play around with the different patterns that are possible, below you can find a kind of \"pattern playground\" which will render the latex that corresponds to the kind of pattern you are constructing. Note that \"patterns.\" or \"p.\" both work as prefixes, though only \"patterns.\" will work as a prefix in the CL editor (unless you've included the line p = patterns ). Additionally, this playground only includes a set of the more common patterns (the ones with explanations currently in this documentation). Input your pattern here: Pattern Preview Pattern Warnings","title":"Pattern Playground"},{"location":"patterns/#kinds-of-patterns","text":"","title":"Kinds of Patterns"},{"location":"patterns/#patternnumber","text":"","title":"pattern.number"},{"location":"patterns/#pattern-attributes","text":"numberPattern Attribute Type Description satisfies(ltx::latex) numberPattern ltx should be some expression containing the variable x which evaluates to either true or false . For example, the following will match only to negative integers: neg_int = patterns.integer.satisfies(`x < 0`) matches(ltx::latex) boolean Description needed parse(ltx::latex) numberPatternMatch Description needed rejectParens numberPattern Description needed allowParens numberPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes","text":"numberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed","title":"Match Attributes"},{"location":"patterns/#patterninteger","text":"","title":"pattern.integer"},{"location":"patterns/#pattern-attributes_1","text":"numberPattern Attribute Type Description satisfies(ltx::latex) numberPattern ltx should be some expression containing the variable x which evaluates to either true or false . For example, the following will match only to negative integers: neg_int = patterns.integer.satisfies(`x < 0`) matches(ltx::latex) boolean Description needed parse(ltx::latex) numberPatternMatch Description needed rejectParens numberPattern Description needed allowParens numberPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_1","text":"numberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed","title":"Match Attributes"},{"location":"patterns/#patternmixednumber","text":"","title":"pattern.mixedNumber"},{"location":"patterns/#pattern-attributes_2","text":"mixedNumberPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) mixedNumberPatternMatch Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_2","text":"mixedNumberPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed whole number Description needed numerator number Description needed denominator number Description needed","title":"Match Attributes"},{"location":"patterns/#patternscientific","text":"","title":"pattern.scientific"},{"location":"patterns/#pattern-attributes_3","text":"scientificPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) scientificPatternMatch Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_3","text":"scientificPatternMatch Attribute Type Description numericValue number Description needed latex latex Description needed coefficient number Description needed exponent number Description needed","title":"Match Attributes"},{"location":"patterns/#patternliteral","text":"patterns.literal(ltx::latex)::literalPattern","title":"pattern.literal"},{"location":"patterns/#pattern-attributes_4","text":"literalPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) literalPatternMatch Description needed rejectParens literalPattern Description needed allowParens literalPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_4","text":"literalPatternMatch Attribute Type Description latex latex Description needed","title":"Match Attributes"},{"location":"patterns/#patternexpression","text":"","title":"pattern.expression"},{"location":"patterns/#pattern-attributes_5","text":"expressionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) expressionPatternMatch Description needed rejectParens expressionPattern Description needed allowParens expressionPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_5","text":"expressionPatternMatch Attribute Type Description latex latex Description needed","title":"Match Attributes"},{"location":"patterns/#patternanyof","text":"patterns.anyOf(term1::pattern, term2::pattern, ...)::orPattern anyOf accepts any number of terms, and will match any of them.","title":"pattern.anyOf"},{"location":"patterns/#pattern-attributes_6","text":"orPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) orPatternMatch Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_6","text":"orPatternMatch Attribute Type Description latex latex Description needed","title":"Match Attributes"},{"location":"patterns/#patternsum","text":"patterns.sum(term1::pattern, term2::pattern, ...)::sumPattern sum accepts any number of terms, and will match their addition.","title":"pattern.sum"},{"location":"patterns/#pattern-attributes_7","text":"sumPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) sumPatternMatch Description needed strictOrder sumPattern Description needed rejectParens sumPattern Description needed allowParens sumPattern Description needed rejectNegativeTerms sumPattern Description needed allowNegativeTerms sumPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_7","text":"sumPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.sum call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the sum, one would call: patterns.sum(patterns.integer, patterns.integer).parse(`1+2`).term1","title":"Match Attributes"},{"location":"patterns/#patterncontains","text":"","title":"pattern.contains"},{"location":"patterns/#pattern-attributes_8","text":"containsPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) containsPatternMatch Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_8","text":"containsPatternMatch Attribute Type Description latex latex Description needed term1 patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patternproduct","text":"patterns.product(term1::pattern, term2::pattern, ...)::productPattern product accepts any number of terms, and will match their product.","title":"pattern.product"},{"location":"patterns/#pattern-attributes_9","text":"productPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) productPatternMatch Description needed strictOrder productPattern Description needed rejectParens productPattern Description needed allowParens productPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_9","text":"productPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.product call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the product, one would call: patterns.product(patterns.integer, patterns.integer).parse(`1*2`).term1","title":"Match Attributes"},{"location":"patterns/#patternjuxt","text":"patterns.juxt(term1::pattern, term2::pattern, ...)::juxtPattern juxt accepts any number of terms, and will match their juxtaposition. WARNING : juxt will not recognize the juxtaposition of two numbers (as these are often parsed as a single number) and in general is not completely intuitive. Make sure to test thoroughly when using this feature.","title":"pattern.juxt"},{"location":"patterns/#pattern-attributes_10","text":"juxtPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) juxtPatternMatch Description needed strictOrder juxtPattern Description needed rejectParens juxtPattern Description needed allowParens juxtPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_10","text":"juxtPatternMatch Attribute Type Description latex latex Description needed termX patternMatch where X is the index of a term in the patterns.juxt call. This returns the patternMatch of the type of the indexed term. For example, to get the match for the first term of the juxt, one would call: patterns.juxt(patterns.integer, patterns.literal(`x`)).parse(`1x`).term1","title":"Match Attributes"},{"location":"patterns/#patternfraction","text":"patterns.fraction(numerator::pattern, denominator::pattern)::fractionPattern","title":"pattern.fraction"},{"location":"patterns/#pattern-attributes_11","text":"fractionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) fractionPatternMatch Description needed rejectParens fractionPattern Description needed allowParens fractionPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_11","text":"fractionPatternMatch Attribute Type Description latex latex Description needed numerator patternMatch Description needed denominator patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patterndivision","text":"patterns.division(dividend::pattern, divisor::pattern)::divisionPattern","title":"pattern.division"},{"location":"patterns/#pattern-attributes_12","text":"divisionPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) divisionPatternMatch Description needed rejectParens divisionPattern Description needed allowParens divisionPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_12","text":"divisionPatternMatch Attribute Type Description latex latex Description needed divisor patternMatch Description needed dividend patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patternradical","text":"patterns.radical(radicand::pattern, degree::pattern)::radicalPattern","title":"pattern.radical"},{"location":"patterns/#pattern-attributes_13","text":"radicalPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) radicalPatternMatch Description needed rejectParens radicalPattern Description needed allowParens radicalPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_13","text":"radicalPatternMatch Attribute Type Description latex latex Description needed radicand patternMatch Description needed degree patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patternoverline","text":"Description Needed","title":"pattern.overLine"},{"location":"patterns/#patternoverarc","text":"Description Needed","title":"pattern.overArc"},{"location":"patterns/#patternoverrightarrow","text":"Description Needed","title":"pattern.overRightArrow"},{"location":"patterns/#patternoverleftarrow","text":"Description Needed","title":"pattern.overLeftArrow"},{"location":"patterns/#patterndifference","text":"patterns.difference(minuend::pattern, subtrahend::pattern)::pattern","title":"pattern.difference"},{"location":"patterns/#pattern-attributes_14","text":"differencePattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) differencePatternMatch Description needed rejectParens differencePattern Description needed allowParens differencePattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_14","text":"differencePatternMatch Attribute Type Description latex latex Description needed minuend patternMatch Description needed subtrahend patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patternrepeat","text":"Description Needed","title":"pattern.repeat"},{"location":"patterns/#patternoptional","text":"Description Needed","title":"pattern.optional"},{"location":"patterns/#patternfunctioncall","text":"Description Needed","title":"pattern.functionCall"},{"location":"patterns/#patternprime","text":"Description Needed","title":"pattern.prime"},{"location":"patterns/#patternexponent","text":"patterns.exponent(base::pattern, exponent::pattern)::exponentPattern","title":"pattern.exponent"},{"location":"patterns/#pattern-attributes_15","text":"exponentPattern Attribute Type Description matches(ltx::latex) boolean Description needed parse(ltx::latex) exponentPatternMatch Description needed rejectParens exponentPattern Description needed allowParens exponentPattern Description needed","title":"Pattern Attributes"},{"location":"patterns/#match-attributes_15","text":"exponentPatternMatch Attribute Type Description latex latex Description needed base patternMatch Description needed exponent patternMatch Description needed","title":"Match Attributes"},{"location":"patterns/#patterncomparator","text":"Description Needed","title":"pattern.comparator"},{"location":"patterns/#patterncomparatorchain","text":"Description Needed","title":"pattern.comparatorChain"},{"location":"patterns/#patternsymbol","text":"Description Needed","title":"pattern.symbol"},{"location":"syntax-intro/","text":"CL Syntax # A great introduction to the Amplify Activity editing environment and CL programming language can be found in the Amplify CL Documentation . Below is a brief summary of the syntax, which will hopefully eventually be filled out more comprehensively Sinks and Sources # There are two ways to interact with CL components, and those are through sinks and sources . Sinks are the way that you set attributes of a component (e.g. the text in a Note, or the drawings in a Sketch), and sources are the ways that you read from a component. The syntax for setting the value of a sink is as follows: sink_name: sink_value Note that this will set the sink of the component whose CL code you are actively editing. Note that, sometimes, sink_name will be followed by parentheses containing some argument (for example, the itemContent source of the Ordered List component). If we want to access the value of a source from a component, we can do that at any place in the activity using the syntax: component_name.source_name For example, let's say that we have a Note component in which we want to display the answer a student put into a Math Response component called math_resp . In the Note component, we would write: content: math_resp.latex This sets the content sink of the Note to the value of the latex source in the Math Response component. For a more comprehensive list of sinks and sources corresponding to each component, take a look at the Components page Variable Assignment # In addition to sinks and sources, CL also allows you to define variables in the CL editor to store values. The basic format for this is: variable_name = variable_value This can be incredibly useful to break up redundancy in your CL code and to make things more readable.","title":"Basic Syntax"},{"location":"syntax-intro/#cl-syntax","text":"A great introduction to the Amplify Activity editing environment and CL programming language can be found in the Amplify CL Documentation . Below is a brief summary of the syntax, which will hopefully eventually be filled out more comprehensively","title":"CL Syntax"},{"location":"syntax-intro/#sinks-and-sources","text":"There are two ways to interact with CL components, and those are through sinks and sources . Sinks are the way that you set attributes of a component (e.g. the text in a Note, or the drawings in a Sketch), and sources are the ways that you read from a component. The syntax for setting the value of a sink is as follows: sink_name: sink_value Note that this will set the sink of the component whose CL code you are actively editing. Note that, sometimes, sink_name will be followed by parentheses containing some argument (for example, the itemContent source of the Ordered List component). If we want to access the value of a source from a component, we can do that at any place in the activity using the syntax: component_name.source_name For example, let's say that we have a Note component in which we want to display the answer a student put into a Math Response component called math_resp . In the Note component, we would write: content: math_resp.latex This sets the content sink of the Note to the value of the latex source in the Math Response component. For a more comprehensive list of sinks and sources corresponding to each component, take a look at the Components page","title":"Sinks and Sources"},{"location":"syntax-intro/#variable-assignment","text":"In addition to sinks and sources, CL also allows you to define variables in the CL editor to store values. The basic format for this is: variable_name = variable_value This can be incredibly useful to break up redundancy in your CL code and to make things more readable.","title":"Variable Assignment"},{"location":"types/","text":"Types # CL supports a variety of data types. One non-primitive data type is List<Type> , which is parameterized by other data types (including, potentially, more lists). NEEDS WORK : The list of types presented below are far from comprehensive, and could be further filled out. Primitive Types # boolean # The simplest datatype in CL, boolean variables can either be true or false . string # A string object is, like in most languages, a list of characters. However, it cannot be indexed directly (i.e. \"test\"[1] will return an error). Strings can be explicitly defined, and support string interpolation. Only variables of type string , latex , or number can be used for string interpolation. For example: x = 5 my_string = \"The value of x is ${x}\" # m_string now contains \"The value of x is 5\" y = true broken_str = \"The value of y is ${y}\" # This returns an error, as boolean-type variables cannot be interpolated latex # The latex object is similar to the string object, but specifically supports latex-like formatting. MORE DETAILS NEEDED number # A number object in CL can contain any real (well, technically rational) number (positive, negative, and decimal). However, note that no number-based operations can happen directly in CL. Instead, operations like adding two numbers together must be formatted as a string using string interpolation, and then sent through the numericValue function to get a value. For example: x = 5 y = 3 z = numericValue(\"${x} + ${y}\") sketch # DETAILS NEEDED component # All components have an attribute script of type componentScript , which allows access to variables defined in other components. DETAILS NEEDED","title":"Types"},{"location":"types/#types","text":"CL supports a variety of data types. One non-primitive data type is List<Type> , which is parameterized by other data types (including, potentially, more lists). NEEDS WORK : The list of types presented below are far from comprehensive, and could be further filled out.","title":"Types"},{"location":"types/#primitive-types","text":"","title":"Primitive Types"},{"location":"types/#boolean","text":"The simplest datatype in CL, boolean variables can either be true or false .","title":"boolean"},{"location":"types/#string","text":"A string object is, like in most languages, a list of characters. However, it cannot be indexed directly (i.e. \"test\"[1] will return an error). Strings can be explicitly defined, and support string interpolation. Only variables of type string , latex , or number can be used for string interpolation. For example: x = 5 my_string = \"The value of x is ${x}\" # m_string now contains \"The value of x is 5\" y = true broken_str = \"The value of y is ${y}\" # This returns an error, as boolean-type variables cannot be interpolated","title":"string"},{"location":"types/#latex","text":"The latex object is similar to the string object, but specifically supports latex-like formatting. MORE DETAILS NEEDED","title":"latex"},{"location":"types/#number","text":"A number object in CL can contain any real (well, technically rational) number (positive, negative, and decimal). However, note that no number-based operations can happen directly in CL. Instead, operations like adding two numbers together must be formatted as a string using string interpolation, and then sent through the numericValue function to get a value. For example: x = 5 y = 3 z = numericValue(\"${x} + ${y}\")","title":"number"},{"location":"types/#sketch","text":"DETAILS NEEDED","title":"sketch"},{"location":"types/#component","text":"All components have an attribute script of type componentScript , which allows access to variables defined in other components. DETAILS NEEDED","title":"component"}]}